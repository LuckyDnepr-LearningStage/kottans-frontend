Методи стандартизовані для HTTP:

- GET: для запиту ресурсу. В URL-адресі міститься вся необхідна інформація для визначення місцезнаходження та повернення ресурсу сервером.
- POST: для створення нового ресурсу. Запити POST звичайно містять дані для створення нового ресурсу.
- PUT: для оновлення існуючого ресурсу. У вмісті можуть знаходитися оновлені дані для ресурсу.
- DELETE: для видалення існуючого ресурсу.

- HEAD: подібний до GET, проте не передається тіло повідомлення.
        Він використовується для отримання заголовків певного ресурсу від сервера, звичайно для того,
        щоб перевірити за допомогою тимчасової позначки, чи не змінився ресурс.
- TRACE: використовується для отримання від сервера інформації про "стрибки" 
        (* найближчий маршрутизатор, маршрутизатор, що знаходиться на відстані одного "стрибка"),
        через які пройшов запит.
- OPTIONS: для отримання підтримуваних сервером можливостей.
        На стороні клієнта його можна використовувати для зміни запиту в залежності від можливостей, підтримуваних сервером.
---------------------------

>>>>>>> Коди стану (* значення, що повертається процедурою або функцією та показує стан пристрою або процесу).

У специфікації HTTP встановлюються певні діапазони чисел для конкретних типів відповідей:

1xx: Інформація про процес передачі
        Усім клієнтам HTTP/1.1 необхідно, щоб у повідомленні був заголовок Transfer-Encoding.

2xx: Інформація про вдалий прийом та оброблення запиту клієнта
        Коди цього класу повідомляють клієнтові, що його запит вдало оброблено.
        Найчастіше зустрічається код (* та відповідна фраза) 200 OK.
        На запити за методом GET сервер відправляє у відповідь запитувані дані в тілі повідомлення.
        Нижче наведено деякі рідше використовувані коди (* та відповідні фрази):

202 Accepted (* Прийнято): запит було прийнято на оброблення (* але його не завершено), але у відповіді може не бути запитуваних даних.
        Цей варіант корисний для асинхронної обробки на стороні сервера.
        Сервер може вирішити відправити інформацію для моніторингу .
204 No Content (* Нема вмісту): тіло повідомлення не передається.
205 Reset Content (* Скинути вміст): клієнт повинен скинути (* повернути вихідні значення)
        уведені користувачем дані (* тіла повідомлення сервер при цьому не передає і документ оновлювати не обов'язково).
206 Partial Content (* Частковий вміст): вказує, що у відповіді міститься тільки частина ресурсу.
        Клієнт може надсилати додаткові заголовки,
        за допомогою яких вказується точний діапазон запитуваного ресурсу та інформація про термін дії контенту.

3xx: Переадресація
        Цей код вказує клієнту, що необхідно буде виконати додаткову дію.
        Найпоширеніший варіант – виконання запиту за іншою URL-адресою 
        (* вказаною у додатковому заголовку Location) для отримання запитуваного ресурсу.

301 Moved Permanently (*  Постійно переміщений): запитуваний об'єкт було остаточно перенесено на новий URL.
303 See Other (* Дивитися інший): запитуваний об'єкт було тимчасово перенесено на нову URL-адресу.
        Тимчасовий URL вказується у заголовку Location відповіді.
304 Not Modified (* Не модифікований): сервер виявив, що ресурс не було змінено і
        клієнту варто використовувати копію з кеш-пам'яті.
        Це реалізується за допомогою того, що клієнт відправляє певне значення (хеш-значення вмісту) у заголовку ETag (Entity Tag).
        Сервер порівнює це значення зі своїм власним токеном (* засіб ідентифікації) для запитуваного ресурсу на наявність змін.

4xx: Інформація про помилки з боку клієнта
        Ці коди використовуються, коли сервер вважає, що клієнт зробив помилку: чи то помилковий запит, чи то запит недоступного для клієнта ресурсу.
        Найбільш популярне повідомлення у цьому випадку – 404 Not Found (*  Не знайдено),
        значення якого, гадаю, всім відомо.
        404 повідомляє, що запитуваний ресурс не існує на сервері.
        Деякі з решти кодів (* і відповідних фраз) цього класу наведено нижче:

400 Bad Request ( Зіпсований запит): у запиті знайдено помилку.
401 Unauthorized (*  Несанкціонований доступ): для здійснення запиту необхідна автентифікація.
        Клієнт може повторно виконати запит, додавши заголовок Authorization.
        Якщо клієнт вже використовував цей заголовок, то це означає, що було вказано помилкові для вдалої автентифікації дані.
403 Forbidden (* Заборонено): сервер відмовив клієнту у доступі до вказаного ресурсу.
405 Method Not Allowed (* Метод не допустимий): у рядку запиту використовувався
        неприпустимий метод HTTP або ж сервер не підтримує цей метод.
409 Conflict (* Конфлікт): сервер не зміг виконати запит, оскільки клієнт спробував змінити ресурс,
        відмітка часу якого не співпадає з такою клієнта.
        У більшості випадків конфліктна ситуація виникає при сумісному редагуванні ресурсу за допомогою запитів за методом PUT.

5xx: Інформація про помилки з боку сервера
Цей тип кодів використовується для повідомлення про невдале виконання операції через помилку з боку сервера. Найчастіше зустрічається код про помилку (* та відповідна фраза) 500 Internal Server Error (* Внутрішня помилка сервера; будь-яка помилка сервера, що не належить до інших помилок класу). До деяких інших кодів (* та відповідних фраз) цього класу належать:

501 Not Implemented (* Не реалізовано): сервер на цей момент не підтримує можливостей, необхідних для оброблення запиту.
503 Service Unavailable (* Сервіс недоступний): сервер не  має можливості оброблювати запити з технічних причин або перевантажений.
        Звичайно сервер навіть не буде відповідати, і запит перевищить ліміт часу очікування від сервера
        (*  timeout; час чекання події (зазвичай задають для операцій з периферійними пристроями),
        з настанням якої виникає й обробляється, наприклад, помилкова ситуація).

>>>>>>> Формат HTTP-повідомлень

У специфікації HTTP визначається наступна загальна структура повідомлень запиту та відповіді:

message = <start-line>
          *(<message-header>)
          CRLF
          [<message-body>]
 
<start-line> = Request-Line | Status-Line 
<message-header> = Field-Name ':' Field-Value

Розміщення пустого рядка між заголовками та тілом повідомлення є обов'язковим.
У повідомленні може міститися один або декілька заголовків, серед котрих умовно (* згідно з контекстом) можна виділити:

- загальні заголовки (general headers; застосовні для повідомлень і запиту, і відповіді).
- заголовки запиту.
- заголовки відповіді.
- заголовки тіла об'єкта (entity headers).

    У тілі повідомлення можуть міститися всі дані повідомлення або воно може бути поділено на частини,
    якщо використовується кодування передачі типу «chunked» (Transfer-Encoding: chunked).
    Усім клієнтам HTTP/1.1 необхідно, щоб у повідомленні був заголовок Transfer-Encoding.

>>>>>>> Загальні заголовки
Є декілька заголовків, що використовуються і в повідомленнях запиту, і в повідомленнях відповіді:

general-header = Cache-Control            
               | Connection        
               | Date              
               | Pragma            
               | Trailer           
               | Transfer-Encoding 
               | Upgrade           
               | Via               
               | Warning

    Заголовок Via використовується у повідомленнях, що передаються за методом TRACE,
        і оновлюється всіма проміжними проксі та шлюзами.
    Заголовок Pragma вважається спеціалізованим заголовком і може бути використаний для додавання
        до повідомлення пов'язаних із конкретною реалізацією додатка заголовків.
        Найчастіше використовується директива Pragma: no-cache, що є еквівалентом 
        Cache-Control: no-cache версії HTTP/1.1.
    Заголовок Date використовується для додавання часу створення повідомлення запиту/відповіді.
    Upgrade  використовується для переключення протоколів і дозволяє здійснювати плавний перехід на використання нового протоколу.
    Transfer-Encoding звичайно використовується для поділення відповіді на менші частини 
        за допомогою директиви Transfer-Encoding: chunked. 
        Цей заголовок вперше з'явився у версії HTTP/1.1; дозволяє реалізувати потокову передачу даних відповіді клієнту 
        (* переміщення даних частинами) (на відміну від пересилання копії даних повністю).

>>>>>>> Заголовки тіла повідомлення
У повідомленнях запиту та відповіді можуть використовуватися заголовки для тіла об'єкта, щоб передати метаінформацію про вміст повідомлення (тіло повідомлення/об'єкта). До цього типу заголовків належать:

entity-header  = Allow                    
               | Content-Encoding  
               | Content-Language  
               | Content-Length    
               | Content-Location  
               | Content-MD5       
               | Content-Range     
               | Content-Type      
               | Expires           
               | Last-Modified

    За допомогою всіх заголовків із префіксом Content- передається інформація про структуру,
        кодування та розмір тіла повідомлення. Деякі із цих заголовків повинні бути, якщо у повідомленні є вміст.

    Завдяки заголовку Expires задається термін, по закінченні якого тіло повідомлення вважається застарілим.
        Цікаво, що при вказанні значення "never expires" цей термін дорівнює одному року.
        За допомогою заголовка Last-Modified вказується час останньої модифікації файлу.

>>>>>>> Формат повідомлень запиту
Загальна структура повідомлень запиту така ж, як і вище, проте рядок запиту виглядає наступним чином:

Request-Line = Method SP URI SP HTTP-Version CRLF
Method = "OPTIONS"
       | "HEAD"  
       | "GET"  
       | "POST"  
       | "PUT"  
       | "DELETE"  
       | "TRACE"
SP – просторовий роздільник між лексемами. На місті HTTP-Version вказується "HTTP/1.1", і потім йде перехід на новий рядок.
Таким чином, типове повідомлення запиту може виглядати наступним чином:


GET /articles/http-basics HTTP/1.1
Host: www.articles.com
Connection: keep-alive
Cache-Control: no-cache
Pragma: no-cache
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8

    Зверніть увагу на рядок запиту, за яким йде серія заголовків запиту. Заголовок Host є обов'язковим для клієнтів,
        що працюють за HTTP/1.1. Запити, виконувані за методом GET, не мають тіла об'єкта, а запити, виконувані за методом POST,
        можуть містити дані в тілі повідомлення для створення ресурсу.

Заголовки запиту грають роль модифікаторів повідомлення запиту. Повний список наявних заголовків запиту не дуже довгий,його наведено нижче:
    Заголовки, що не входять до списку, розглядаються як поля заголовка об'єкта.

request-header = Accept                   
               | Accept-Charset    
               | Accept-Encoding   
               | Accept-Language   
               | Authorization     
               | Expect            
               | From              
               | Host              
               | If-Match          
               | If-Modified-Since 
               | If-None-Match     
               | If-Range          
               | If-Unmodified-Since
               | Max-Forwards       
               | Proxy-Authorization
               | Range              
               | Referer            
               | TE                 
               | User-Agent

>>>>>>> Формат повідомлень відповіді

Формат повідомлень відповіді схожий з таким повідомлень запиту, за винятком стартового рядка та заголовків. Стартовий рядок має наступну структуру:

Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF

На місті HTTP-Version вказується "HTTP/1.1".
Status-Code – один із раніше розглядуваних кодів стану.
Reason-Phrase – зрозуміла для людини версія (* пояснююча фраза) коду стану.

Типовий стартовий рядок відповіді про вдале виконання запиту може виглядати наступним чином:

HTTP/1.1 200 OK

Кількість заголовків відповіді також доволі обмежена; повний набір наведено нижче:

response-header = Accept-Ranges
                | Age
                | ETag              
                | Location          
                | Proxy-Authenticate
                | Retry-After       
                | Server            
                | Vary              
                | WWW-Authenticate

У Age вказується час у секундах, коли повідомлення було згенеровано на сервері.
Значення ETag – хеш-значення об'єкта, отримане за допомогою алгоритму шифрування MD5 (* Message Digest 5);
    використовується для перевірки наявності змін ресурсу.
Location використовується для інструктування клієнта про переадресацію та містить нову URL-адресу.
У Server вказується сервер, що надіслав повідомлення.